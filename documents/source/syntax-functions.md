# Functions

Makex files have functions available which do different things:

## `task()`

This function defines a Task which will become part of the execution graph.

```{todo}
"target" is an overloaded term in software construction (e.g "target architecture").
```

The task function is as follows:

```{eval-rst}
.. py:function:: task(name, requires=None, steps=None, outputs=None)
  
  :param String name: Name of the task.
      
  :param list[PathLike] requires: A list of requirements. Can be files or other tasks using a task locator or reference.
    A string with a : will be parsed as a task reference. Any values which evaluated to None will be skipped.
  
  :param list[Union[Action,list[Action]]] steps: A list of :ref:`actions`. These are actions/task/executables/scripts run in sequence as part of the task.
  
  :param Union[PathLike, list[PathLike], dict[String, PathLike]] outputs: A file or list of the files this task outputs. 
    If a task produces any files that are to be consumed by any dependents of the task, they *should* be defined here. 
    Defining outputs makes the task a candidate for caching.
      
```

```{note}
In previous versions of Makex, this function was named `target()`; this is not supported anymore. Please rename to `task()`.
```

<!--
```{note}
This function is provided under the alias `Task()` as `task` may be a commonly used macro local variable/argument.
```


path=None,
:param list[PathLike] path: Path to the task's output directory.
This will be automatically generated by default. You may define a path shared between
tasks by assigning a variable with the :py:func:`path` function and passing the returned Path.
  .. note:: The `path` argument is deprecated and may be removed, or placed behind a flag. 
     It's absolutely unsafe.
-->

Example of creating a task named `world` which depends on `hello`:

```python

task(
    name="world",
    requires=[
        ":hello"
    ],
    steps=[
        print("World!")
    ],
)

task(
    name="hello",
    requires=[
    ],
    steps=[
        print("Hello")
    ],
)
```

Running the `world` task will run the `hello` task first (using `makex run :world`). The printed output will be:

```
Hello
World!
```


## Paths

Makex standardizes on paths with `/` as a separator.

Paths in Makex files may not contain the `..` (double dot) marker.

<!--
This shouldn't be a problem unless you are on Windows and doing something specific.

If you need a different seperator for a Path object use the {py:class}`WindowsPath` object.
-->

```{note}
Any specifics or problems in the {py:mod}`Python pathlib module <pathlib>` will show up in Makex.
```

## path()

To refer to arbitrary paths use the `path()` function to produce a path object.

Any paths in Makex files can be joined with a separator using the `/` operator.

```{eval-rst}
.. py:function:: path(*path:PathLike) -> Path
  
  Return a Path object.
  
  :param path: One or more path components.
```


```{eval-rst}
.. py:class:: Path

    A path object. Similar to :py:class:`pathlib.Path`. Paths can be concatenated with separators
    by using the `/` operator.
    
    .. py:attribute:: name
      :type: String
      
      The name of the path; typically a file name. This is the last component/part of any given path.
      The name of the root (`/`) is an empty string.
      
```
<!--
### WindowsPath()

```{eval-rst}
.. py:class:: WindowsPath

    A path object. Similar to :py:class:`pathlib.PureWindowsPath`.
```
-->

## task_path()

The `task_path()` function will return the output {class}`Path` for the specified task.
See {doc}`the Tasks<tasks>` and {doc}`the Cache<caching>` documentation for more about Task output paths.

```{todo}
Since `path` is a common variable (e.g. in a loop), and as an argument (to Tasks), 
and also a class/object {class}`Path`, we should provide the alternative functions `cache()` or `build()`. 
All of these functions do the same thing.
```


```{eval-rst}
.. py:function:: task_path(name:String, path:PathLike=None) -> Path
  
  Returns an output path for a task with `name`. If the `path` argument is specified, returns the output path corresponding
  to the task with the matching `name` inside of a Makex file at `path`.  
  
  The output path of a task is typically `MakexFile.folder / "_output_" / Task.identity`.
  
  :param name: Name of a task.
  :param path: Optional. A folder containing a Makex file.
    Workspace relative paths are accepted here.
    
```

```{note}
If `DIRECT_REFERENCES_TO_MAKEX_FILES` is enabled, the `path` argument may be a path to a Makex file.
```

## home()

```{eval-rst}
.. py:function:: home(*path:PathLike=None) -> Path
  
  Return a Path that evaluates to the current user's home directory.
  
  :param path: Optional. A subpath in the home directory.
```

## find()

```{eval-rst}
.. py:function:: find(path:PathLike, include:Union[Pattern,Glob]=None) -> list[Path]
  
  Finds files (recursively). If path is relative, it will be resolved relative to the folder of the makex file (the source folder).
  
  This function is typically intended to arbitrarily find source files to operate on.
  
  Note: this function is intended to be used as part of Task or its actions; find will not return/resolve otherwise.  
  
  :param path: A path to search for files in.
  :param Union[Pattern,Glob] include: Files to include. If specified, only files matching the include will be returned.
```

## glob()

```{eval-rst}
.. py:function:: glob(pattern:String=None) -> Glob
  
  Prepares/compiles a glob pattern.
  
  Note: this function is intended to be used as part of Task or its actions; glob will not return/resolve otherwise.  
  
  When used alone within a task (e.g. as part of a tasks inputs/dependencies), globs will match files within the source folder
  of the task (or, the same folder in which the makex file exists).
  
  :param pattern: Patterns of files to include.
```

Globs support the following syntax: 

- `/` to separate path segments.
- `*` to match zero or more characters in a path segment.
- `?` to match on one character in a path segment.
- `**` to match zero or more folders. (e.g. `**.py` will match python files in any directory)
- `[]` to declare a range of characters to match.
- `{}` to declare a set of patterns to match.
- `[!...]` to negate a range of characters to match.

```{tip}

Match a file with extension: `*.c`

Match a file with extension recursively: `**.c`

Match files with multiple extensions: `*.{py,md,txt}`
```
