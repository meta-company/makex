```{eval-rst}
:tocdepth: 3
```
# Makex Files

## Syntax

Makex Files are a restricted subset of {ref}`The Python Programming Language<python:reference-index>`.

Refer to the [Starlark Language Specification](https://github.com/bazelbuild/starlark/blob/master/spec.md) for some applicable restrictions; e.g.:

> Starlark has stricter syntactic limitations than Python. 
> For example, it does not permit for loops or if statements at top level, nor does it permit global variables to be bound more than once. 
> These limitations come from the Bazel project's desire to make it easy to identify the sole statement that defines each global, permitting accurate cross-reference documentation.

```{tip}
Keep your Makex Files simple. Don't be too clever. 
Makex files must evaluate quickly without subprocesses.
```


```{note}
Import statements (`import ...` or `from ... import ...`) are not allowed in Makex Files. Future versions of makex will include modularization features.
```


```{eval-rst}
 
.. todo: document restrictions and syntax.
``` 

## Naming

The name of the Makex File should be one of the following:

- `Makexfile`
- `makexfile`
<!-- `Build`
- `BUILD` -->

The default names to search can be changed with the {data}`makex.makex_files<TOML.makex.makex_files>` configurable.

<!--
The name of a file can be specified absolutely.

The list of files to check can be specified on the {option}`command line<makex --makex-file-names>` or configuration file.
--> 

If several of these files exist in a directory, they will be searched in the order specified. They will be tested, in order, for a 
magic marker to see if they are a Makex file and the first Makex-looking file will be parsed.


## Magic marker/Hashbang/Shebang

A marker `#!makex` at the top of the file both serves to mark the file as a script and to differentiate makex files from other types of files.

```python
#!makex
```

The word makex can be anywhere on the line after the `#!`.

## Commenting

```python

# This is a single line comment.

"""
This is a 
multiline comment.
"""
```


## Strings

String objects in Makex have the following structure:


```{eval-rst}
.. py:class:: String
  
  The makex string object. You cannot instantiate this object directly.
  Use quotes and/or f-strings to define strings.
  
  .. py:method:: replace(value, substitute)
     
    Replaces all `value` with substitute in a String.
      
    :rtype: String
```

```{note}
A wide range of built-in methods for {py:class}`Python strings <str>` and other primitive types (such as  {py:class}`lists <list>` and  {py:class}`dictionaries <dict>`) are not defined or enabled.
```


## Functions

Makex files have functions available which do different things.

### target()

The most important function is target().

This function defines a Target/Objective which will become part of the execution graph.

A Target may be an objective, goal or task (or series of tasks); these terms may be used synonymously.

```{todo}
"target" is an overloaded term in software construction (e.g "target architecture").
```

The target function is defined as follows:

```{eval-rst}
.. py:function:: target(name, path=None, requires=None, runs=None, outputs=None)
  
  Define a Target.
  
  :param String name: Name of the target.
  :param list[PathLike] path: Path to the target's output directory. 
    This will be automatically generated by default. You may define a path shared between 
    targets by assigning a variable with the :py:func:`path` function and passing the returned Path.
    
    .. note:: The `path` argument is deprecated and may be removed, or placed behind a flag. It's absolutely unsafe.
    
  :param list[PathLike] requires: A list of requrements. Can be files or other targets using a target specifier, or using the `Target` function.
    A string with a : will be parsed as a target. Any values which evaluated to None will be skipped.
  
  :param list[Runnable] runs: A list of :ref:`runnables`. The are actions/task/executables/scripts to run as part of the target.
  
  :param list[PathLike] outputs: A list of the files this target outputs. If a target produces any files that are to be consumed by any dependendants of the target, they *should* be defined here. 
    Defining outputs makes the target a candidate for caching.
      
```

Blank example of creating a target named `name`:

```python
target(
    name="name",
    requires=[
    ],
    runs=[
        
    ],
    outputs=[
        
    ]
)
```


### Paths

Makex standardizes on paths with `/` as a separator.

Paths in Makex files may not contain the `..` (double dot) marker.

<!--
This shouldn't be a problem unless you are on Windows and doing something specific.

If you need a different seperator for a Path object use the {py:class}`WindowsPath` object.
-->

```{note}
Any specifics or problems in the {py:mod}`Python pathlib module <pathlib>` will show up in Makex.
```

### Path()

To refer to arbitrary paths uses the `Path` object.

```{eval-rst}
.. py:class:: Path

    A path object. Similar to :py:class:`pathlib.Path`. Paths can be concatenated with separators
    by using the `/` operator.
    
    .. py:attribute:: name
      :type: String
      
      The name of the path; typically a file name. This is the last component/part of any given path.
      The name of the root is an empty string.
      
```
<!--
### WindowsPath()

```{eval-rst}
.. py:class:: WindowsPath

    A path object. Similar to :py:class:`pathlib.PureWindowsPath`.
```
-->

### path()

The `path()` function will return the output {class}`Path` for the specified target.
See {doc}`the Targets<targets>` and {doc}`the Cache<caching>` documentation for more about Target output paths.

<!--
Since `path` is a common variable (e.g. in a loop), and as an argument (to Targets), and also a class/object {class}`Path`,
we provide the alternative functions `cache()` or `build()`. All of these functions do the same thing.

-->


```{eval-rst}
.. py:function:: path(name:String, path:PathLike=None) -> Path
  
  Returns an output path for a target with `name`. If the `path` argument is specified, returns the output path corresponding
  to the target with the matching `name` inside `path`.  
  
  The output path of a target is typically `Target.directory / "_output_" / Target.id`.
  
  :param name: Name of a target.
  :param path: Optional. A directory containing a Makex file.
    Workspace relative paths are accepted here.
    
```

```{note}
If `DIRECT_REFERENCES_TO_MAKEX_FILES` is enabled, the `path` argument may be a path to a Makex file.
```


### Runnables

Each target can accept a list of "Runnables". These are a list of things that will be run when the target is executed.

#### print()

```{eval-rst}
.. py:function:: print(message)
  
  Print a message to standard output.
  
  :param String message: The message to print.
```

#### copy()

```{eval-rst}
.. py:function:: copy(paths, destination=None, /)
  
  Copy `paths` to the specified destination `destination`.
  Paths may be a list of paths or a single path.
  
  If not specified, `destination` is the Target's output directory. If `destination` is a relative path, it will be resolved
  relative to the Target's output path; this may be used to prefix items in the output.
  Any directories specified in `destination` (by using a directory seperator) will be created before copying.
  
  If inputs is a list, the destination path must be a directory.
  An Execution error will be raised if the destination exists, and it is not a directory.
  
  If the destination is empty, the specified `paths` (files or directories) will be copied directly into the Target's output path.
  
  If the destination is a directory, and it doesn't exist, it will be created.
  
  :param Union[PathLike,list[PathLike]] paths: Paths to the file(s) or folder(s) to copy. Relative paths are resolved relative to the makex file.
  
  :param PathLike destination: The destination. May be a path relative to the target output path, or an absolute path.
```

#### execute()


```{eval-rst}
.. py:function:: execute(*executable:Union[str|PathLike,list[str|PathLike]])
  
  Execute an executable. 
  
  Executables are run from the target's directory (the input root).
  
  The first value in executable is the executable to run. This may be a relative (to the target's directory) path, a absolute path, or a name of an executable.
  If it's a name (without any slashes), it will be searched for in the paths defined inside the PATH environment variable.
  
  Followed by the executable is a variable number of arguments passed to the executable.
  
  Any arguments which evaluate to None will not be included when running the executable. 
   
  .. note::
   
    Arguments are passed to the executable as is, with no shell expansion. 
    If you use `~` to denote a home directory, you will need to expand it, or use the :func:`shell()<shell>` function.
  
  .. If you need system specific shell/variable expansion,
     use the expand() function.
   
  Arguments should be quoted and separated as required by the executable.
  Typically, this means passing each argument and value as a separate string.
```

#### write()


```{eval-rst}
.. py:function:: write(file:PathLike, data:Union[str,list[str]], executable:bool=False)
  
  Writes `data` to `file`.
  
  :param PathLike file: The destination file. May be a Workspace path, an absolute path, or relative path within the target path.
  :param Union[str,list[str]] data: The data to write, may be a list of strings which will be concatenated.
  :param bool executable: Ensure the file is executable.
```

#### shell()


```{eval-rst}
.. py:function:: shell(*script)
  
  Run script in a system shell.
  
  .. warning:: 
  
    You should seriously avoid use of this function. Shells may introduce unexpected behavior in Makex.
    
    For example, the line `shell(f"rm {SOME_VARIABLE}/bin")`) will attempt to remove your `/bin` directory if
    SOME_VARIABLE is defined as an empty string.  
    
    shell() is there if you really need it, and additional mechanisms will be employed in the future to increase safety. Keep your
    scripts simple.
    
    Makex may a adopt a "strict" mode where all shell scripting is disabled.
  
  By default, Makex will use the detected/system shell (usually, `sh`, or the Bourne Shell). A shell can be specified in configuration, but it's
  recommened to leave it to autodectect based on platform. 
    
  The passed script is prefixed with a preamble by default: 
  
  .. code-block:: shell
  
    set -Eeuo pipefail
  
  :param script: The script/command line to run. If a list of strings, the items will concatenated with new lines separators
    and run in one process/shell.
  :type script: Union[String,list[String]]
  
  .. note::
  
    The syntax of the script depends on the system's shell.
    Variables are expanded according the specified shell's rules. 
```


## Self Documentation

A multiline comment string may be included at the top of the file to document the file.

This string may be written in markdown with restructured text to provide help or description in other formats/renderings.


## Formatting

When calling functions or constructing lists you should leave an extra comma at the end of the list.
This helps when adding or changing values later.

It is preferred to break functions/callables with keyword arguments into separate lines with a keyword argument per line.

We plan to introduce automatic formatting.

Keep your Makex files simple.

```python

# bad
alist = [1,2,3]

# good
alist = [
    1,
    2,
    3,
]

# bad 
target(
    name="bad", requires=[
        Target("bad"), Target("Bad")
    ]
)

# good
target(
    name="bad",
    requires=[
        Target("bad"), 
        Target("Bad"),
    ],
)

```
